## 生产事故之Python计算精度有问题？

### 背景

我们的生产环境中有一个python脚本，用来将若干个数据库中的数据整合到一个单一的库中，
整合的过程涉及一些计算，其中的一个计算是这样的：  

> 有一个days字段的数据类似于 “100D+2.5Y” 这种，其中“+”前代表多少天，“+”后代
表多少年，我们要做的就是取到这个字段后，把这个字段根据“+”进行split分割，取分割后
的字符串数据的第0个值，然后判断其后缀。如果为D，直接把D前面的数值型字符串转换成
float，然后ceil取整后赋值给另一个daySort字段；如果是Y，则把Y前面的数值型字符串
转换成float，再乘以365，然后ceil取整后赋值给daySort。  

部分的代码大概是下面这样的：
```

```

### 问题

这样的代码经过测试后上了生产，并正常运行了一两个月，然后突然有一天，产品找到我们，
说有bug，现象就是days字段排序不正确（这里要说明下，上述背景中的days字段是用于前端
展示的，展示的内容就是 “100D+2.5Y” 这样，而该字段又需要有排序功能，所以增加的这个
daySort字段就是为了排序用的），具体来说就是当按days字段的升序进行排序后，发现会有
8D、9D、9D、8D、10D。。。的现象，即出现了乱序的现象。

### 初查

有了问题当然要第一时间排查，而具体的办法就是寻根溯源。于是我们打开chrome的开发模式
定位到了乱序的这一条数据，例如上文里面紧跟9D后面的8D这一条。于是我们发现这条数据的
days字段值确实是8D，但计算出来的daySort值却是9，然后等我们再排查其他的数据，发现这
种现象还不在少数，当然正常的数据也有很多，各方排查无果后，自然就有了题目所示的疑问：
**是否python的计算精度有问题？或者环境有问题？**  

### 乱查

但是怀疑归怀疑，却不能以此作为结论，我们需要的是证据以及解决的办法。于是，各种上网查，
查python是否有类似的bug提出；各种尝试，比如是否是因为做了float转换导致的，如果直接
int转换的是否就没问题；各种折腾。。。  
最后python方面似乎没问题，至少网上没找到有提出类似问题的，各种尝试也都不奏效，往往是
单独的函数测试没问题，一拿到脚本中试就有问题，而且是有的数据有问题，有的数据没问题，
而且有还是没有也没有发现任何的规律性。。。

### 结论

该问题最后的解决是当初写这个脚本的同事排查了一天，当天查到晚上10点多才查到具体的原因，
然后进行修正的。因为这个问题还牵扯到另一个需求，所以说这个结论之前，还是先把另一个需
求的情况简要说说，从中也可以看出公司项目管理及团队合作等方面的一些问题。

### 另一个背景

话说在我们上面的这个需求上线生产之后几天，另一个需求也跟着上线了生产。后面的这个需求
是另一个产品经理（此位的口碑在我们部门比较统一。。。的差）负责的，是一个小需求，也不
是我们负责的，所以我们不清楚。后来了解到，这个需求虽小，动的地方却很关键，因为这个需
求需要改数据库里的数据，具体地说就是，应业务的要求，数据库中的days字段要改下保存的格
式，由原来的 “100D+2.5Y” 改成 “0.2740Y+2.5Y”，即所有的天都不要了，全部改成年的形式。
改的过程知道的人不多，可以说是静悄悄地就进行了，直到一石激起千层浪。。。  
准确地说，改这个数据他们并不是一点没考虑别的影响，比如我们的那个python脚本，对days的
取值还是做了一定的调整的，将小于1年的值通过四舍五入换算成了天，代码如下：
```

```
但是上面那个问题的出现说明考虑的还是不够，至于还有没有其他问题，只能等bug自己暴露出来
了，或者有人力的话把所有的相关代码都捋一遍。

### 真相

至此，其实真相也差不多算揭示出来了。原因就是我们之前的需求，计算daySort时，是直接取
days的值进行计算的，且计算的是ceil的值，即所有的小数都会直接进1，后来这个需求虽然也有
改动那个脚本，但却是加在脚本最后的，即在计算了daySort之后，再去计算新的days的值，而计
算这个新的days的值用的是round函数，即是四舍五入的值。由此，计算出来的结果必然会有问题，
我们的解决办法也很简单，把计算新的days的过程放在计算daySort之前进行就可以了。

### 总结
1. 项目的管理很重要，尤其当项目比较多、杂，且相互间有数据或逻辑方面的耦合时，更要做好规
划管理和流程控制。这块我目前仅能看出来我们的问题挺严重，但还提不出有效的解决方案。
2. 任何需求如果要改动现有的数据或代码，就一定要充分考虑其影响范围，执行尽量充分的回归测
试。当然这里的充分也只能尽量，只要改了就很难保证一定没问题，所以最好的方案就是不要动原有
的东西，尤其是基础性的多方都在用的东西。这也是开闭原则的要求。
3. 解决问题的思路要开阔，当然这可能会受到经验缺乏的限制。思路太僵化，容易钻牛角尖，进入
死胡同。比如这个问题，最后可能就会把重点放在去查找python的bug去了。